"use strict";(self.webpackChunkmundis_docs=self.webpackChunkmundis_docs||[]).push([[403],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),d=l(n),p=s,m=d["".concat(c,".").concat(p)]||d[p]||u[p]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function p(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=d;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r.mdxType="string"==typeof e?e:s,i[1]=r;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2349:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return c},default:function(){return p},frontMatter:function(){return r},metadata:function(){return l},toc:function(){return u}});var a=n(7462),s=n(3366),o=(n(7294),n(3905)),i=["components"],r={title:"Layer 1"},c=void 0,l={unversionedId:"backbone/layer1",id:"backbone/layer1",title:"Layer 1",description:"A L1 chain (or side-chain) is a business-specific application that runs in the Multiverse (i.e., a world or a Metaverse). They are smaller, independent chains that manage their own consensus and have control over how blocks are generated. L0 does not verify or execute L1 transactions, and it only notarizes valid L1 blocks through the timeline. L1 chains are independent, interoperable application systems that benefit from Global Services. Inter-L1 communication is achieved using messages routed through L0.",source:"@site/src/backbone/layer1.md",sourceDirName:"backbone",slug:"/backbone/layer1",permalink:"/backbone/layer1",draft:!1,tags:[],version:"current",frontMatter:{title:"Layer 1"},sidebar:"docs",previous:{title:"Layer 0",permalink:"/backbone/layer0"},next:{title:"Global Services",permalink:"/backbone/services"}},h={},u=[{value:"Governors",id:"governors",level:2},{value:"Ruling system",id:"ruling-system",level:2},{value:"Assets",id:"assets",level:2},{value:"Smart Contracts",id:"smart-contracts",level:2},{value:"Security",id:"security",level:2}],d={toc:u};function p(e){var t=e.components,n=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"A L1 chain (or side-chain) is a business-specific application that runs in the Multiverse (i.e., a world or a Metaverse). They are smaller, independent chains that manage their own consensus and have control over how blocks are generated. L0 does not verify or execute L1 transactions, and it only notarizes valid L1 blocks through the timeline. L1 chains are independent, interoperable application systems that benefit from Global Services. Inter-L1 communication is achieved using messages routed through L0."),(0,o.kt)("p",null,"The main feature of L1 chains is the ability to move assets between them, enabling complete interoperability of Metaverse worlds and asset interchangeability. Assets are designed to be fungible like coins or tokens or non-fungible such as NFTs. "),(0,o.kt)("p",null,"Consensus inside L1 chains is Proof of Stake (PoS) with an optimized BFT state-machine designed for high speed and fast finality, enabling fast block production and finality. This is important because L1 chains need to support a wide range of business and consumer applications, from DeFI systems to games."),(0,o.kt)("p",null,"L1 chains can be developed using Substrate as the main SDK. Substrate takes a modular approach to chain development by defining a rich set of blockchain primitives for developers to use. L1 developers can create their own custom runtime using the Framework for Runtime Aggregation of Modularized Entities (FRAME) and pallets available in Substrate or directly with Substrate Core."),(0,o.kt)("p",null,"Upon genesis, an L1 must be registered in the L0 registry, a database-like construct that holds both static and dynamic information on each L1. Part of the registration process is to generate an identity keypair for the new L1, create an L1 genesis account in L0 and deposit an amount of L0 tokens in the respective account. The identity keypair will be used in the genesis configuration of the respective L1 chain."),(0,o.kt)("p",null,"L1 operations include the suspension and removal of L1 chains. Suspension can happen only if the L1 chain account has no more Mundis tokens available in their L0 account registry, and the owner of the L1 chain must add funds to reinstate his chain."),(0,o.kt)("p",null,"The removal (garbage collection) of an L1 altogether would come in the following circumstances:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The L1 is suspended for a long period of time. "),(0,o.kt)("li",{parentName:"ul"},"The L1 doesn't have Governor support anymore and is not producing blocks "),(0,o.kt)("li",{parentName:"ul"},"Through an L0 referendum: this should be an emergency measure only, available for rogue L1 chains that demonstrate malicious behavior like spamming other L1 chains with inter-L1 transactions.")),(0,o.kt)("h2",{id:"governors"},"Governors"),(0,o.kt)("p",null,"Governors are nodes that maintain an L1 chain by validating transactions and participating in the consensus of that L1. Since an L1 has Proof-of-Stake (PoS) consensus, Governors must stake Mundis tokens to become eligible validators for an L1 chain."),(0,o.kt)("p",null,"It's up to the creator of an L1 to recruit Governors for its project, and Mundis provides the LaunchPad to help. Creators can list new projects for free on the LaunchPad, and citizens decide whether they pledge support for the project or not. A project that has citizen support has greater chances to attract Governors."),(0,o.kt)("p",null,"The economics of an L1 is also a decisive factor to consider for Governors. The creator must carefully design the economics of its new L1 to be attractive (i.e., governors must be rewarded for validating blocks)."),(0,o.kt)("h2",{id:"ruling-system"},"Ruling system"),(0,o.kt)("p",null,"When creating a new L1 chain, builders can set genesis rules that enforce how the L1 will work. Genesis rules define bootstrap parameters and consensus rules. Bootstrap parameters set the initial state of the L1, the configuration of the economic system (e.g., tokens issued, inflation, etc.), and access to L0 Services, DAO enablement, etc."),(0,o.kt)("p",null,"Consensus rules, on the other hand, configure how block finality is achieved and what happens when a block is finalized. Rules are flexible to allow any use-case to be implemented. Consensus rules also determine the minimum number of Governors needed to support the L1 chain. If the L1 chain does not gather or maintain enough Governor support, it will be Garbage Collected by L0 to free up Metaverse resources."),(0,o.kt)("p",null,"The builder of an L1 chain can choose a DAO model for governance. The Governors will be included in the DAO and have voting rights on the L1 consensus rules. The DAO model promotes active participation in the life of a World and creates decentralization. Governors will probably prefer to join an L1 chain with a DAO model as extra insurance for their stake."),(0,o.kt)("h2",{id:"assets"},"Assets"),(0,o.kt)("p",null,"An L1 chain can have both fungible and non-fungible assets. Assets are designed to be fungible like tokens or non-fungible like NFTs. "),(0,o.kt)("p",null,"The main goal of Mundis is to promote interoperability. Exchange of assets must be supported between L1 chains and between an L1 chains and L0. We chose Parity's cross-consensus message format XCM to enable native exchange of assets with XCM-enabled blockchains. "),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/xcm-format"},"XCM")," provides different methods to transfer assets between chains, as stated in the Cross-Consensus Message (XCM) Format specification:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Remote Transfers"),": control an account on a remote chain, allowing the local chain to have an address on the remote chain for receiving funds and to eventually transfer those funds it controls into other accounts on that remote chain "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Teleporting"),": movement of an asset happens by destroying it on one side and creating a clone on the other side "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Reverse-Based Transfer"),": there may be two chains that want to nominate a third chain, where one includes a native asset that can be used as a reserve for that asset. Then, the derivative form of the asset on each of those chains would be fully backed, allowing the derivative asset to be exchanged for the underlying asset on the reserve chain backing it")),(0,o.kt)("p",null,"The XCM protocol is designed to be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Asynchronous"),": XCM messages in no way assume that the sender will be blocking on its completion"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Absolute"),": XCM messages are guaranteed to be delivered and interpreted accurately, in order, and in a timely fashion."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Asymmetric"),": XCM messages do not have results. Any results must be separately communicated to the sender with an additional message."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Agnostic"),": XCM makes no assumptions about the nature of the Consensus System between which messages are being passed.")),(0,o.kt)("p",null,"The actual message parsing between L0 and L1 chains is handled using queues. L0 can send messages to L1 chains by posting a message in the L1 chain's input queue. In a similar way, an L1 chain can post a message in the L0 input queue. This also enables the exchange of messages between L1 chains. It is the task of L0 to move transactions from the output queue of one L1 chain into the input queue of the destination L0 chain. In the L0 timeline, only the hash of the associated metadata is stored. The input/output queues must have a limited size to prevent spamming."),(0,o.kt)("p",null,"The Anatomy of an L1 inter-chain Interaction:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"smart contract that exists on L1 chain A will route a message to L1 chain B, where another smart contract is called to make a transfer of some assets within L1 chain B. "),(0,o.kt)("li",{parentName:"ol"},"Charlie executes the smart contract on L1 chain A, which initiates a new cross-chain message for the destination of a smart contract on L1 chain B."),(0,o.kt)("li",{parentName:"ol"},"A governor of L1 chain A will place this new cross-chain message in the L0 inbound message queue, along with message_id, destination, and a timestamp."),(0,o.kt)("li",{parentName:"ol"},"An L0 architect picks up the message and determines the destination L1 chain (using the destination field), and places the message in the inbound message queue of L1 chain B."),(0,o.kt)("li",{parentName:"ol"},"A governor of B will see this new message and add it for processing into the next block. While processing, the message will trigger smart contract execution on L1 chain B and complete the asset transfer as intended."),(0,o.kt)("li",{parentName:"ol"},"After finalizing the block on L1 chain B, its hash and message_id will be submitted to L0 for inclusion in the global timeline."),(0,o.kt)("li",{parentName:"ol"},"L0 will notify L1 chain A that the communication is completed and provide an optional result.")),(0,o.kt)("h2",{id:"smart-contracts"},"Smart Contracts"),(0,o.kt)("p",null,"Substrate provides a Contracts pallet that allows the L1 runtime to deploy and execute WASM smart contracts. As described in the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.substrate.io/v3/getting-started/overview/"},"Substrate SDK")," documentation, the smart-contract code is stored once in a code cache and later retrievable via its hash. This means that multiple smart contracts can be instantiated from the same hash without replicating the code each time. When a smart contract is invoked, the associated code is retrieved and executed via the code hash. This call can modify the smart-contract account's storage entries, instantiate new smart contracts, or invoke other smart contracts."),(0,o.kt)("p",null,"Contract users must specify a gas limit with each call, as the smart contract's instructions require gas. Unused gas is refunded following the call, regardless of the outcome of the execution. When the gas limit is reached, all calls and state changes (including balance transfers) are reverted only at the contract level of the current call. For instance, if contract A calls B and B runs out of gas in the middle of the call, all of B's calls are reverted. Assuming contract A handles errors correctly, A's other calls and state changes continue to occur."),(0,o.kt)("h2",{id:"security"},"Security"),(0,o.kt)("p",null,"L1 chains have Proof of Stake (PoS) consensus and are assumed to be adversarial by default since they are permissionless untrusted networks of unknown participants. An L1 chain needs active Governors and be alive for several epochs to be considered for inclusion in the L0 timeline and be able to consume L0 services."),(0,o.kt)("p",null,"In a multichain network, major security issues arise from cross-chain assets, because in PoS chains, attackers can hardly profit from a purely internal attack. On Mundis, if Governors act maliciously in the L1 consensus process, anyone can challenge them by submitting fraud proofs to L0. Fraud Proofs present evidence that a state transition was incorrect. The main advantage of Fraud Proofs is that they are not needed for every state transition, but only when things supposedly break down. They require fewer computational resources and are a better fit for a scalability-constrained environment."),(0,o.kt)("p",null,"There are two types of fraud-proof corresponding to two kinds of malicious actions that can be challenged:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"a group of L1 Governors signed two different headers at the same height."),(0,o.kt)("li",{parentName:"ol"},"a group of L1 Governors voted on a block that included invalid transactions.")),(0,o.kt)("p",null,"The 1st type of fraud-proof can be verified by L0 directly. L0 tracks all public keys of L1 Governors and uses the same public-key cryptography and curve with L1 chains. Once the challenge is verified, the slashing process is invoked automatically. Governors who signed the duplicate header will be slashed. The severity depends on the summed voting power of the faulty Governors. If the voting power is 33% or more, 100% of the stake will be slashed. These penalties are transferred to an on-chain L0 treasury. L0 will then halt the corrupted L1 chain, and its future would be dependent on a L0 governance decision."),(0,o.kt)("p",null,"The 2nd type of fraud-proof can't be verified directly by L0. So, once this type of fraud-proof is received, L0 pauses the staking/delegation operation and any cross-chain asset transfers into and out of the L1 chain. A governance process is then triggered on L0 to make a judgment and take corresponding actions. There is ongoing research to automate this process."),(0,o.kt)("p",null,"Another problem is data availability. While most systems rely on a data availability proof that which is complex and expensive, Mundis uses a challenge-response game. All L1 Governors must continually observe L0, specifically the light client corresponding to its own L1 chain inside the L0, which acts as the Root-of-Trust for cross-chain asset transferring. A malicious group of Governors could forge a header and update the light client in L0 but hide block content from honest Governors. By doing that, the malicious group may steal cross-chain assets from the mainchain that are locked in the L0 bridge or transfer fake L1 assets to L0."),(0,o.kt)("p",null,"Suppose an honest L1 chain Governor finds a newly committed block header in the chain's light client on L0 but doesn't have the corresponding block data. In this case, he would submit a query transmission to L0 expressing doubt. If he receives the block afterward, he would then withdraw the query. But if one L1 chain accumulates many queries on the same height, L0 will emit data availability challenges. In this situation, the header signers\u2019 responsibility is to submit a valid block that justifies the header. Should they fail to do so, their staking would be slashed. If the duration of this challenge-response game is significantly shorter than the unbonding period \u2014 and the total staking on the L1 caps the cross-chain assets \u2014 there is no chance for attackers to profit by hiding blocks."))}p.isMDXComponent=!0}}]);